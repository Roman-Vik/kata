- Этот алгоритм также использует метод "разделяй и властвуй" для сортировки массива. Он работает следующим образом:
- Разделяет массив на две половины.
- Рекурсивно сортирует каждую половину.
- Сливает две отсортированные половины в один отсортированный массив.
- ### Полный код с подробными комментариями
  
  ```go
  package main
  
  import "fmt"
  
  // Функция сортировки слиянием
  func mergeSort(arr []int) []int {
    // Базовый случай: если массив содержит 1 или 0 элементов, он уже отсортирован
    if len(arr) <= 1 {
        return arr
    }
  
    // Находим середину массива
    mid := len(arr) / 2
  
    // Рекурсивно сортируем левую и правую половины
    left := mergeSort(arr[:mid])
    right := mergeSort(arr[mid:])
  
    // Сливаем отсортированные половины
    return merge(left, right)
  }
  
  // Функция для слияния двух отсортированных массивов в один
  func merge(left, right []int) []int {
    // Создаем результирующий массив
    result := make([]int, 0, len(left)+len(right))
  
    // Сливаем элементы из left и right в result
    for len(left) > 0 && len(right) > 0 {
        if left[0] <= right[0] {
            result = append(result, left[0]) // Добавляем элемент из left в result
            left = left[1:]                  // Удаляем первый элемент из left
        } else {
            result = append(result, right[0]) // Добавляем элемент из right в result
            right = right[1:]                 // Удаляем первый элемент из right
        }
    }
  
    // Добавляем оставшиеся элементы из left или right в result
    result = append(result, left...)
    result = append(result, right...)
    
    return result
  }
  
  func main() {
    // Исходный массив
    arr := []int{64, 34, 25, 12, 22, 11, 90}
  
    // Вызываем сортировку слиянием
    sortedArr := mergeSort(arr)
  
    // Печатаем отсортированный массив
    fmt.Println("Sorted array:", sortedArr)
  }
  ```
- ### Пошаговое объяснение
- #### Исходный массив
  
  ```go
  arr := []int{64, 34, 25, 12, 22, 11, 90}
  ```
- #### Первый вызов  `mergeSort`
  
  ```go
  mergeSort(arr)
  ```
- **Проверка базового случая**:
	- `len(arr) = 7`, так что массив не пуст и содержит более одного элемента.
- **Нахождение середины массива**:
	- `mid := len(arr) / 2 = 7 / 2 = 3`.
- **Рекурсивный вызов для левой половины**:
  
  ```go
  left := mergeSort(arr[:mid])
  ```
	- `arr[:mid]` даст `[64, 34, 25]`.
- **Рекурсивный вызов для правой половины**:
  
  ```go
  right := mergeSort(arr[mid:])
  ```
	- `arr[mid:]` даст `[12, 22, 11, 90]`.
- ### Рекурсивные вызовы
  
  Этот процесс повторяется для каждого подмассива, пока каждый подмассив не будет содержать один элемент или станет пустым.
- #### Пример для левой половины
  
  ```go
  left := mergeSort([]int{64, 34, 25})
  ```
- **Разделение на подмассивы**:
	- `left = mergeSort([]int{64})`
	- `right = mergeSort([]int{34, 25})`
- **Продолжение до базового случая**:
	- `mergeSort([]int{34, 25})` разделится на `[]int{34}` и `[]int{25}`.
	- Эти массивы уже содержат один элемент, так что они возвращаются как есть.
- ### Слияние
  
  Когда массивы достигли базового случая, начинается процесс слияния.
- #### Слияние примера
  
  ```go
  merge([]int{34}, []int{25})
  ```
- **Создание пустого результирующего массива**:
  
  ```go
  result := make([]int, 0, len(left)+len(right))
  ```
- **Сравнение первых элементов**:
	- `left[0] = 34`, `right[0] = 25`.
	- `25 <= 34`, так что добавляем `25` в `result` и удаляем его из `right`.
	- `result = [25]`, `right = []`.
- **Добавление оставшихся элементов**:
	- `left` не пуст, так что добавляем все его элементы в `result`.
	- `result = [25, 34]`.
	  
	  Этот процесс повторяется для всех подмассивов.
- ### Итоговый отсортированный массив
  
  После завершения всех рекурсивных вызовов и слияний, массив станет отсортированным:
  
  ```go
  [11, 12, 22, 25, 34, 64, 90]
  ```
- ### Вывод отсортированного массива
  
  ```go
  fmt.Println("Sorted array:", sortedArr)
  ```