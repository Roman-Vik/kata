## 1 Применение хороших практик
	- [[Что такое принцип DRY (Don’t Repeat Yourself)]]
	- [[Что такое принцип YAGNI (You Ain’t Gonna Need It)]]
	- [[Что такое принцип KISS (Keep It Simple, Stupid]]
	- [[bshcxbdshbc]]
	-
- ## SOLID
  collapsed:: true
	- [[Что такое SOLID]]
	- [[Назови принципы SOLID]]
	- [[Что такое Single Responsibility Principle?]]
	- [[Что такое Open / Closed Principle]]
	- [[Что такое  Liskov Substitution Principle]]
	- [[Что такое Interface Segregation Principle]]
	- [[Что такое Dependency Inversion Principle]]
- ## Рефакторинг
	- [[Что такое рефакторинг]]
	- [[Что такое грязный код]]
- #### **2 Применение ООП**
  collapsed:: true
	- [[Является ли язык golang ООП языком?]]
	- [[Абстракция]]
	- [[Полиморфизм в go:]]
	- [[Отчилия Абстракции от Полиморфизма]]
	- [[Инкапсуляция]]
- [Введение в ООП. Наследование, абстракция, полиморфизм, инкапсуляция.](https://proglib.io/p/samouchitel-po-go-dlya-nachinayushchih-chast-10-vvedenie-v-oop-nasledovanie-abstrakciya-polimorfizm-inkapsulyaciya-2024-03-11)
- #### 2.1 Планирование и абстрактный объект
	- **Планирование**
	  collapsed:: true
		- — это процесс определения целей программы или кода, спецификаций, требований и архитектуры системы.
		- Это важный этап, позволяет определить цели проекта, спецификации, требования и архитектуру системы и включает в себя определение функциональности, создание диаграмм, определение интерфейсов и тестирование.
		-
	- #### Модель  «водопад»  (waterfall model)
	  collapsed:: true
		- классическая моделей жизненного цикла разработки программного обеспечения, кторая включает в себя этапа разработки:
		- определение требований;
		  logseq.order-list-type:: number
		- проектирование;
		  logseq.order-list-type:: number
		- разработку;
		  logseq.order-list-type:: number
		- тестирование;
		  logseq.order-list-type:: number
		- внедрение.
		  logseq.order-list-type:: number
		- Этапы предполагают последовательное выполнение, где каждый следующий этап начинается только после завершения предыдущего.
	- #### Ассоциация (has-a) и Агрегация (has-a) в голанг
	  collapsed:: true
		- ### Ассоциация
		  
		  Ассоциация представляет собой общее отношение между двумя классами, где один класс использует функциональность другого класса. Это отношение не обязательно указывает на владение одним классом другим. Например, врач может быть ассоциирован с несколькими пациентами, но это не означает, что врач "владеет" пациентами в смысле управления их жизненным циклом.
		- В Go, как и в других языках программирования, концепции ассоциации (has-a) и агрегации (has-a) используются для описания отношений между объектами или структурами данных. Однако, важно понимать, что Go не поддерживает классическое наследование и полноценные объекты в том смысле, как это делают языки с поддержкой классов. Вместо этого, Go использует структуры и интерфейсы для достижения подобного поведения. Давайте рассмотрим эти концепции на примере.
		- ### Ассоциация
		  
		  Ассоциация означает, что одна структура содержит ссылку на другую структуру. Это может быть реализовано через поля структур. В контексте Go, это часто называют "владением" (`has-a`), но более точное название — это просто "ассоциация", поскольку владение подразумевает возможность управления жизненным циклом объекта, чего нет в Go из-за его систем управления памятью.
		  
		  Пример ассоциации:
		  
		  ```go
		  type Car struct {
		    brand string
		  }
		  
		  type Person struct {
		    name   string
		    car    *Car // Ассоциация: у человека есть машина
		  }
		  ```
		  
		  В этом примере, `Person` ассоциирован с `Car`, имея в себе указатель на `Car`. Это позволяет `Person` иметь доступ к свойствам и методам `Car`.
		- ### Агрегация
		  
		  Агрегация — это специальный случай ассоциации, где одна структура включает в себя другие структуры без явного представления отношения владения. В Go, агрегация обычно достигается путем включения структур напрямую в составной тип без использования указателей или интерфейсов.
		  
		  Пример агрегации:
		- ```go
		  type Engine struct {
		    power int
		  }
		  
		  type Car struct {
		    brand string
		    engine Engine // Агрегация: машина состоит из двигателя
		  }
		  ```
		  
		  Здесь `Car` агрегирует `Engine`, включая его непосредственно в свою структуру. Это позволяет `Car` использовать свойства и методы `Engine`, но без явного отражения отношения владения через указатели.
		- ### Отличие
		  
		  Основное отличие между ассоциацией и агрегацией заключается в способе связи между структурами:
		- **Ассоциация** обычно реализуется через указатели или интерфейсы, что позволяет одной структуре управлять другой или изменять связь во время выполнения программы.
		- **Агрегация** достигается за счет прямого включения одной структуры в составную структуру, что создает статическую связь между ними.
		  
		  В Go, выбор между ассоциацией и агрегацией зависит от конкретных требований к дизайну и взаимодействию между компонентами системы.
		-
		- ### Ассоциация
		  
		  Ассоциация представляет собой общее отношение между двумя классами, где один класс использует функциональность другого класса. Это отношение не обязательно указывает на владение одним классом другим. Например, врач может быть ассоциирован с несколькими пациентами, но это не означает, что врач "владеет" пациентами в смысле управления их жизненным циклом.
		- ### Агрегация
		  
		  Агрегация является специальным случаем ассоциации, который описывает отношение "целое-часть", где части могут существовать независимо от целого. Например, список номеров телефонов может быть агрегатом, состоящим из множества отдельных номеров телефонов. Каждый номер телефона может существовать независимо от списка.
		- ### Основные различия
		- **Отношение**: Ассоциация описывает общее использование функциональности одного класса другим, в то время как агрегация описывает отношение "целое-часть", где части могут существовать независимо.
		- **Владение**: В ассоциации нет явного указания на владение, тогда как в агрегации части могут существовать независимо от целого.
		- **Примеры**: Врач-пациент (ассоциация) против списка номеров телефонов (агрегация).
		- ### Примеры на Go
		  
		  Поскольку Go не имеет классического наследования и полноценных объектов, мы можем использовать структуры и интерфейсы для демонстрации этих концепций.
		- #### Ассоциация
		  
		  ```go
		  type Doctor struct{}
		  
		  type Patient struct{}
		  
		  func (d *Doctor) Treat(p *Patient) {}
		  ```
		  В этом примере, `Doctor` ассоциирован с `Patient`, но не "владеет" им в смысле управления жизненным циклом.
		- #### Агрегация
		- ```go
		  type PhoneNumber struct {
		    Number string
		  }
		  
		  type ContactList struct {
		    Phones []PhoneNumber
		  }
		  ```
		  
		  Здесь `ContactList` агрегирует `PhoneNumber`, но каждый номер телефона может существовать независимо от списка контактов.
		  
		  Эти примеры иллюстрируют основные различия между ассоциацией и агрегацией, подчеркивая, что в Go эти концепции реализуются через структуры и интерфейсы, а не через механизмы наследования и полноценных объектов, как в некоторых других языках программирования.
	-
-
- #### **3 Паттерны**
- #### **4 Структуры данных и алгоритмы**
- #### ** Оптимизация**
- ### Понятия
	- [[Что такое контракт?]]
	- [[Типы, подтипы что это такое]]
	- [[Основные моменты Принципа Подстановки Лисков]]
	- [[Принцип подстановки Лисков vs Утиная типизация]]
	- [[Отличия Принципа ]]
-