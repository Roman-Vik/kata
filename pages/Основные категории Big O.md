- **O(1)** — **Константное время** (если знаем индекс то поиск по индексу)
  collapsed:: true
	- Время выполнения не зависит от размера входных данных.
	- Пример: доступ к элементу массива по индексу. Неважно, сколько элементов в массиве, доступ к элементу занимает одно и то же время.
	- ### **На человеческом языке**
		- ### Пример из реальной жизни
		  
		  Представь, что ты открываешь книгу на конкретной странице:
		- Если у тебя книга на 100 страниц, ты можешь сразу открыть страницу 50.
		- Если у тебя книга на 1000 страниц, ты также можешь сразу открыть страницу 50.
		  
		  Время, которое тебе потребуется, чтобы открыть конкретную страницу, не зависит от общего количества страниц в книге. Это и есть пример O(1).
		- ### Пример в программировании
		- **Доступ к элементу массива по индексу**:
			- Неважно, сколько элементов в массиве, доступ к элементу по индексу всегда занимает одно и то же время.
			  
			  ```go
			  func getElement(arr []int, index int) int {
			   return arr[index]
			  }
			  
			  func main() {
			   arr := []int{10, 20, 30, 40, 50}
			   element := getElement(arr, 2) // Получаем элемент по индексу 2
			   fmt.Println("Элемент:", element) // Вывод: Элемент: 30
			  }
			  ```
		- **Проверка условия**:
			- Проверка какого-либо условия, которое не зависит от входных данных.
			  
			  ```go
			  func isEven(number int) bool {
			   return number%2 == 0
			  }
			  
			  func main() {
			   number := 42
			   if isEven(number) {
			       fmt.Println(number, "четное")
			   } else {
			       fmt.Println(number, "нечетное")
			   }
			  }
			  ```
		- ### Почему это важно?
		  
		  Понимание O(1) важно, потому что такие алгоритмы самые быстрые и самые предсказуемые. Независимо от размера данных, они всегда выполняются за одно и то же фиксированное время. Это делает их особенно полезными в ситуациях, где важна высокая производительность.
		- ### Примеры в реальной жизни:
		- **Включение света**: Включение выключателя света занимает одно и то же время, независимо от того, сколько лампочек в комнате.
		- **Доступ к ячейке памяти**: В компьютере доступ к конкретной ячейке памяти занимает одно и то же время, независимо от общего объема памяти.
		- ### Заключение
		  
		  O(1) — это когда алгоритм выполняется за одно и то же фиксированное время, независимо от размера входных данных. Это делает такие алгоритмы самыми быстрыми и самыми предсказуемыми. Понимание временной сложности O(1) помогает оценить эффективность алгоритмов и выбрать наиболее подходящие для решения конкретных задач.
- **O(n)** — **Линейное время** (цикл всех элементов)
  collapsed:: true
	- Время выполнения увеличивается пропорционально размеру входных данных.
	- Пример: проход по массиву. Если у тебя массив из 10 элементов, ты пройдёшь по всем 10. Если в массиве 100 элементов, ты пройдёшь по всем 100.
	- ### **На человеческом языке**
	  collapsed:: true
		- ### Примеры ситуаций с O(n):
		- **Поиск элемента**:
		  Если нужно найти максимальное значение в массиве, нужно проверить каждый элемент:
		  ```go
		  func findMax(arr []int) int {
		    max := arr[0]
		    for _, value := range arr {
		        if value > max {
		            max = value
		        }
		    }
		    return max
		  }
		  ```
		- **Подсчет элементов**:
		  Подсчет количества каждого символа в строке:
		  ```go
		  func countCharacters(text string) map[rune]int {
		    counts := make(map[rune]int)
		    for _, char := range text {
		        counts[char]++
		    }
		    return counts
		  }
		  ```
		- **Сумма всех элементов**:
		  Сложение всех элементов в массиве:
		  
		  ```go
		  func sumArray(arr []int) int {
		    sum := 0
		    for _, value := range arr {
		        sum += value
		    }
		    return sum
		  }
		  ```
		- ### В чем отличие от других временных сложностей?
		- **O(1)**: Время выполнения алгоритма не зависит от размера входных данных. Пример — доступ к элементу массива по индексу.
		- **O(n²)**: Время выполнения алгоритма увеличивается пропорционально квадрату размера входных данных. Пример — вложенные циклы, проходящие по массиву.
		- ### Примеры в реальной жизни:
		- **Перебор списка**: Представь, что у тебя есть список покупок, и ты хочешь вычеркнуть каждый пункт по мере того, как его находишь в магазине. Время, которое ты потратишь, будет линейно зависеть от количества пунктов в списке.
		- **Подсчет голосов**: Если у тебя есть список голосов на выборах, и ты хочешь подсчитать общее количество голосов, тебе нужно будет пройти по каждому голосу один раз.
		- ### Заключение
		  
		  O(n) — это когда алгоритм должен задействовать каждый элемент входных данных хотя бы один раз для выполнения своей задачи. Это означает, что время выполнения алгоритма увеличивается линейно с увеличением размера входных данных. Понимание этого помогает оценить эффективность алгоритмов и выбрать подходящий для конкретной задачи.
- **O(n²)** — **Квадратичное время**(вложенный цикл всех  элементов)
  collapsed:: true
	- Время выполнения увеличивается пропорционально квадрату размера входных данных.
	- Пример: вложенные циклы, где каждый цикл проходит по всем элементам массива. Если в массиве 10 элементов, будет 10 * 10 = 100 операций. Если 100 элементов, то 100 * 100 = 10,000 операций.
	- ### **На человеческом языке**
	  collapsed:: true
		- ### Пример из реальной жизни
		  
		  Представь, что у тебя есть список гостей, и ты хочешь, чтобы каждый гость пожал руку каждому другому гостю:
		- Если у тебя 1 гость, он никому не будет жать руку.
		- Если у тебя 10 гостей, каждый из 10 гостей будет жать руку 9 другим гостям, то есть будет 10 * 9 = 90 рукопожатий.
		- Если у тебя 100 гостей, каждый из 100 гостей будет жать руку 99 другим гостям, то есть будет 100 * 99 = 9,900 рукопожатий.
		  
		  В данном случае время выполнения (количество рукопожатий) увеличивается пропорционально квадрату количества гостей.
		- ### Пример в программировании
		- collapsed:: true
		  
		  **Сортировка пузырьком (Bubble Sort)**:
			- Этот алгоритм сортирует массив, сравнивая каждую пару соседних элементов и меняя их местами, если они не в порядке.
			- Вложенные циклы проходят по массиву несколько раз.
			  
			  ```go
			  func bubbleSort(arr []int) {
			   n := len(arr)
			   for i := 0; i < n; i++ {
			       for j := 0; j < n-i-1; j++ {
			           if arr[j] > arr[j+1] {
			               arr[j], arr[j+1] = arr[j+1], arr[j]
			           }
			       }
			   }
			  }
			  
			  func main() {
			   arr := []int{64, 34, 25, 12, 22, 11, 90}
			   bubbleSort(arr)
			   fmt.Println("Отсортированный массив:", arr)
			  }
			  ```
		- collapsed:: true
		  
		  **Поиск всех пар элементов в массиве**:
			- Пример, где нужно найти все пары элементов в массиве.
			  
			  ```
			  go
			  
			  Копировать код
			  
			  func printAllPairs(arr []int) {
			   n := len(arr)
			   for i := 0; i < n; i++ {
			       for j := 0; j < n; j++ {
			           fmt.Println(arr[i], arr[j])
			       }
			   }
			  }
			  
			  func main() {
			   arr := []int{1, 2, 3, 4}
			   printAllPairs(arr)
			  }
			  ```
		- ### Почему это важно?
		  
		  Понимание O(n²) важно, потому что такие алгоритмы быстро становятся неэффективными с увеличением размера входных данных. Если количество данных увеличивается вдвое, время выполнения увеличивается в четыре раза (2²). Поэтому для больших данных такие алгоритмы могут быть слишком медленными.
		- ### В чем отличие от других временных сложностей?
		- **O(n)**: Время выполнения увеличивается линейно с увеличением размера входных данных.
		- **O(n²)**: Время выполнения увеличивается квадратично, то есть гораздо быстрее с увеличением размера входных данных.
		- ### Примеры в реальной жизни:
		- **Турнир по шахматам**: В круговом турнире каждый участник играет с каждым другим участником. Если есть 10 участников, то будет 10 * 9 / 2 = 45 игр. Если 100 участников, то будет 100 * 99 / 2 = 4,950 игр.
		- **Сравнение каждого элемента с каждым другим**: Представь, что у тебя есть список продуктов, и ты хочешь сравнить каждый продукт с каждым другим, чтобы найти лучший.
		- ### Заключение
		  
		  O(n²) — это когда алгоритм имеет вложенные циклы, каждый из которых проходит по всем элементам входных данных. Это означает, что время выполнения алгоритма увеличивается квадратично с увеличением размера входных данных. Понимание этого помогает оценить, насколько алгоритм эффективен для больших объемов данных и выбрать оптимальное решение для конкретной задачи.
- **O(log n)** — **Логарифмическое время**(примерно пополам)
  collapsed:: true
	- Время выполнения увеличивается логарифмически относительно размера входных данных.
	- Пример: бинарный поиск. Если в массиве 1,000 элементов, потребуется примерно 10 шагов, чтобы найти элемент (логарифм по основанию 2 от 1,000 это примерно 10). Если 1,000,000 элементов, то потребуется около 20 шагов.
	- ### **На человеческом языке**
	  collapsed:: true
		- Давай разберем временную сложность O(log n) простыми словами и на конкретных примерах.
		- ### Что такое O(log n)?
		  
		  O(log n) — это **логарифмическое время выполнения**. Это означает, что время выполнения алгоритма увеличивается логарифмически с увеличением размера входных данных. Чаще всего это встречается в алгоритмах, которые на каждом шаге уменьшают объем данных, с которыми работают, примерно вдвое.
		- ### Пример из реальной жизни
		  
		  Представь, что ты ищешь слово в толстой книге:
		- Ты открываешь книгу на середине и смотришь, находится ли нужное слово в первой или во второй половине книги.
		- Затем ты снова делишь соответствующую половину пополам и повторяешь процесс.
		- Таким образом, ты каждый раз сокращаешь объем поиска вдвое.
		  
		  Если книга имеет 1,000 страниц, тебе потребуется около 10 шагов, чтобы найти слово. Если книга имеет 1,000,000 страниц, потребуется около 20 шагов. В обоих случаях количество шагов растет гораздо медленнее, чем количество страниц.
		- ### Пример в программировании
		- **Бинарный поиск (Binary Search)**:
			- Бинарный поиск работает на отсортированном массиве и на каждом шаге делит массив пополам, чтобы найти нужный элемент.
			  
			  ```go
			  func binarySearch(arr []int, target int) int {
			   left, right := 0, len(arr)-1
			   for left <= right {
			       mid := left + (right-left)/2
			       if arr[mid] == target {
			           return mid
			       }
			       if arr[mid] < target {
			           left = mid + 1
			       } else {
			           right = mid - 1
			       }
			   }
			   return -1 // Если элемент не найден
			  }
			  
			  func main() {
			   arr := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
			   target := 7
			   result := binarySearch(arr, target)
			   if result != -1 {
			       fmt.Printf("Элемент %d найден на позиции %d\n", target, result)
			   } else {
			       fmt.Println("Элемент не найден")
			   }
			  }
			  ```
		- ### Почему это важно?
		  Понимание O(log n) важно, потому что такие алгоритмы очень эффективны при работе с большими объемами данных. Время выполнения растет очень медленно по сравнению с размером данных, что делает эти алгоритмы особенно полезными для задач, требующих быстрой обработки.
		- ### Примеры в реальной жизни:
		- **Игра в угадай число**: Представь, что кто-то загадал число от 1 до 100, и ты должен его угадать. Ты спрашиваешь: "Это число больше 50?" и, в зависимости от ответа, сокращаешь диапазон поиска вдвое. Потом спрашиваешь про середину оставшегося диапазона и так далее.
		- **Телефонная книга**: Если ты ищешь фамилию в телефонной книге, ты открываешь ее примерно на середине и смотришь, в какой половине находится нужная фамилия. Потом снова делишь соответствующую половину пополам и так далее.
		- ### Заключение
		  
		  O(log n) — это когда время выполнения алгоритма увеличивается логарифмически с увеличением размера входных данных. Это делает такие алгоритмы очень эффективными для больших объемов данных, так как каждый шаг значительно сокращает объем работы. Понимание временной сложности O(log n) помогает оценить эффективность алгоритмов и выбрать наиболее подходящие для задач, требующих быстрой обработки больших объемов данных.
- **O(n log n)** — **Линейно-логарифмическое время**
  collapsed:: true
	- Время выполнения увеличивается как произведение линейного и логарифмического роста.
	- Пример: сортировка слиянием (merge sort). Если массив из 1,000 элементов, потребуется примерно 10,000 операций. Если 1,000,000 элементов, то потребуется около 20,000,000 операций.
	- **На человеческом языке**
		- ### Что такое O(n log n)?
		  
		  O(n log n) — это **линейно-логарифмическое время выполнения**. Это означает, что время выполнения алгоритма увеличивается как произведение линейного роста (n) и логарифмического роста (log n). Это часто встречается в алгоритмах сортировки, таких как сортировка слиянием (merge sort) и быстрая сортировка (quick sort).
		- ### Пример с сортировкой книг
		  
		  Представь, что у тебя есть библиотека с большим количеством книг, и все они неупорядочены. Ты хочешь отсортировать эти книги по алфавиту (по названию). Однако у тебя нет компьютера, только ты и куча книг.
		- **Разделение на группы**:
			- Ты начинаешь делить все книги на две группы, разделяя их на половину. Например, все книги, начинающиеся с букв A-M, и все книги, начинающиеся с букв N-Z, попадают в разные группы.
			- Затем ты берешь каждую группу и снова делаешь разделение на две части. Теперь у тебя, например, части с книгами A-D, E-H, и т.д.
		- **Сортировка внутри каждой группы**:
			- Каждую отдельную часть книг ты начинаешь сортировать внутри себя. Например, если у тебя есть группа книг с буквами A-D, ты устраиваешь их в правильном алфавитном порядке.
		- **Объединение отсортированных частей**:
			- После того как каждая группа книг отсортирована, ты начинаешь объединять их обратно в один большой список, убеждаясь, что весь список книг теперь отсортирован по названиям.
			  
			  Этот процесс напоминает сортировку слиянием (merge sort) в компьютерной науке. В ней массив (или список) разделяется на две части, каждая из которых сортируется отдельно, а затем объединяется обратно в один отсортированный массив.
		- ### Пример в программировании
		- **Сортировка слиянием (Merge Sort)**:
			- Сортировка слиянием делит массив на две половины, рекурсивно сортирует каждую половину и затем сливает их обратно в один отсортированный массив.
			  
			  ```go
			  func mergeSort(arr []int) []int {
			   if len(arr) <= 1 {
			       return arr
			   }
			  
			   mid := len(arr) / 2
			   left := mergeSort(arr[:mid])
			   right := mergeSort(arr[mid:])
			  
			   return merge(left, right)
			  }
			  
			  func merge(left, right []int) []int {
			   result := []int{}
			   i, j := 0, 0
			  
			   for i < len(left) && j < len(right) {
			       if left[i] < right[j] {
			           result = append(result, left[i])
			           i++
			       } else {
			           result = append(result, right[j])
			           j++
			       }
			   }
			  
			   result = append(result, left[i:]...)
			   result = append(result, right[j:]...)
			  
			   return result
			  }
			  
			  func main() {
			   arr := []int{38, 27, 43, 3, 9, 82, 10}
			   sortedArr := mergeSort(arr)
			   fmt.Println("Отсортированный массив:", sortedArr)
			  }
			  ```
		- ### Почему это важно?
		  
		  Понимание O(n log n) важно, потому что такие алгоритмы сортировки часто являются оптимальными для общих задач сортировки. Они эффективнее, чем квадратичные алгоритмы (например, сортировка пузырьком с O(n²)), особенно для больших объемов данных.
		- ### Примеры в реальной жизни:
		- **Разделение и объединение задач**: Представь, что у тебя есть большое количество заданий, и ты сначала разделяешь их на несколько групп, затем снова делишь каждую группу на подгруппы и так далее, пока не получишь мелкие задачи. После этого ты начинаешь решать эти задачи и объединять результаты. Этот процесс требует линейно-логарифмического времени.
		- **Организация турниров**: В круговом турнире команды сначала делятся на группы, затем проходят групповые этапы, и в конце происходит объединение результатов и проведение финальных матчей.
		- ### Заключение
		  
		  O(n log n) — это когда время выполнения алгоритма увеличивается как произведение линейного и логарифмического роста. Это делает такие алгоритмы очень эффективными для задач сортировки и других задач, требующих многократного деления данных на части и последующего объединения. Понимание временной сложности O(n log n) помогает оценить эффективность алгоритмов и выбрать наиболее подходящие для обработки больших объемов данных.
-
- Жеребьёвка Лиги Чемпионов - отличный пример применения алгоритма сортировки, похожего на сортировку слиянием.
  collapsed:: true
	- **Разделение на группы**:
		- В начале жеребьёвки команды делятся на разные группы или "горшки", например, по странам или по результатам предыдущих сезонов. Каждая группа содержит несколько команд.
	- **Сортировка внутри группы**:
		- Внутри каждой группы команды могут быть упорядочены по определённым критериям, например, по последним спортивным достижениям или по рейтингу команды.
	- **Объединение отсортированных групп**:
		- После сортировки каждой группы начинается жеребьёвка, где команды из разных групп объединяются и распределяются в пары (матчи).
	- ### Пример
	  
	  Предположим, что происходит жеребьёвка группового этапа Лиги Чемпионов:
	- **Разделение на группы**:
		- Команды разбиваются на группы (горшки) по коэффициентам, занимаемым в рейтинге УЕФА, или по странам, в которых они выступают. Например, в группу A попадают команды из Испании, Германии, Италии, и так далее.
	- **Сортировка внутри группы**:
		- В каждой группе команды могут быть упорядочены по рейтингу, чтобы учесть их предыдущие успехи в соревнованиях.
	- **Объединение отсортированных групп**:
		- Затем проводится жеребьёвка, где команды из разных групп (например, команды из группы A, B, C и т.д.) объединяются в пары, которые будут играть друг с другом в матчах группового этапа.
		  
		  Этот процесс подчиняется логике сортировки слиянием: начинается с разделения команд на группы, затем в каждой группе команды могут быть отсортированы по рейтингу, и в конце происходит объединение групп для формирования пар матчей. Такой подход позволяет эффективно организовать жеребьёвку и учесть различные критерии при формировании пар.
		  
		  Таким образом, жеребьёвка Лиги Чемпионов является хорошим примером применения алгоритма, аналогичного сортировке слиянием, для эффективного разделения и упорядочивания команд перед началом турнира.