- ```go
  package main
  
  import (
  	"fmt"
  )
  
  // Animal - интерфейс, абстракция она же контракт
  // Это абстракция, потому что она определяет общий контракт для всех животных,
  // скрывая детали реализации.
  type Animal interface {
  	Speak() string
  	Eat() string
  }
  
  // Dog и Cat - структуры, реализующие интерфейс Animal
  // Они реализуют интерфейс Animal, предоставляя свою уникальную реализацию методов.
  type Dog struct{}
  
  func (d Dog) Speak() string {
  	return "Woof!"
  }
  
  func (d Dog) Eat() string {
  	return "Bones"
  }
  
  type Cat struct{}
  
  func (c Cat) Speak() string {
  	return "Meow!"
  }
  
  func (c Cat) Eat() string {
  	return "Fish"
  }
  
  // main - функция, демонстрирующая полиморфизм
  func main() {
  	animals := []Animal{Dog{}, Cat{}}
  
  	for _, animal := range animals {
  		fmt.Println(animal.Speak())
  		fmt.Println(animal.Eat())
  	}
  }
  ```
- ### Комментарии:
- **Абстракция**: Определение интерфейса `Animal` является примером абстракции. Интерфейс определяет контракт, который должны соблюдать все животные, включая то, что они могут говорить (`Speak`) и есть (`Eat`), но не указывает, как именно они это делают. Это позволяет нам работать с различными типами животных так, как если бы они были одним типом, скрывая их внутренние детали.
- **Полиморфизм**: В цикле `for` в функции `main` мы создаем слайс `animals`, который содержит элементы разных типов (`Dog` и `Cat`), но все они реализуют интерфейс `Animal`. Это демонстрирует полиморфизм, поскольку мы можем обращаться к каждому элементу слайса как к `Animal`, несмотря на то, что каждый из них имеет свою уникальную реализацию методов `Speak` и `Eat`. Полиморфизм позволяет нам писать код, который работает с различными типами данных так, как будто они являются одним типом, благодаря общему интерфейсу.
  
  Отличие между абстракцией и полиморфизмом заключается в том, что абстракция фокусируется на определении общего контракта или интерфейса, скрывая детали реализации, в то время как полиморфизм позволяет использовать объекты разных типов как экземпляры одного и того же интерфейса, обеспечивая гибкость и расширяемость кода.