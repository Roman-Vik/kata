### receiver
collapsed:: true
	- **Получатель** — это параметр того типа, к которому прикрепляется метод.
	- ![image.png](../assets/image_1718126831143_0.png)
- ### deploy
  collapsed:: true
	- это процесс развертывания, установки и запуска программного обеспечения или приложения на целевой системе или сервере, чтобы оно стало доступным для использования конечным пользователям.
	  
	  В контексте разработки программного обеспечения "deploy" обычно означает:
	- **Перенос приложения**:
		- После того как приложение разработано и протестировано локально или на тестовом сервере, процесс deploy включает перенос (или загрузку) приложения на конечное место назначения, такое как хостинг-провайдер, облачная платформа или сервер.
	- **Установка и настройка**:
		- Приложение должно быть установлено на целевой сервер и настроено для корректной работы с учетом конфигурационных параметров и требований окружения.
	- **Запуск и проверка**:
		- После установки и настройки приложение запускается на целевом сервере. После этого проводится ряд проверок, чтобы убедиться, что приложение работает как ожидается и доступно для конечных пользователей.
	- **Мониторинг и обслуживание**:
		- После успешного развертывания приложения необходимо проводить мониторинг его работы и реагировать на любые проблемы или отклонения в его работе. Также могут проводиться регулярные обновления и поддержка приложения.
		  
		  Таким образом, "deploy" является важным этапом в жизненном цикле разработки программного обеспечения, который позволяет превратить разработанный код в полноценное и доступное для использования приложение.
- ### атоманрная операция (atomic operation)
  collapsed:: true
	- Атомарные операции используются в асинхронном программировании для безопасного доступа к разделяемым данным из нескольких потоков или горутин. Они предотвращают гонки данных, потерю данных и неправильные результаты при одновременном доступе к общим ресурсам. В языке Go, например, они часто используются для безопасного обновления глобальных счетчиков, флагов состояния и других разделяемых переменных в асинхронном окружении.
	- в асинхронном программировании, где множество задач выполняется параллельно или конкурентно, атомарные операции могут использоваться для обеспечения безопасности доступа к разделяемым ресурсам.
	- Например, если вы запускаете несколько горутин (goroutines) в языке Go или асинхронные функции в других языках, и они все должны обновлять одну и ту же переменную, такую как счетчик или флаг состояния, в этом случае использование атомарных операций становится крайне важным.
	- Без атомарных операций может произойти гонка данных, что приведет к непредсказуемому поведению вашего приложения. Например, если две горутины одновременно пытаются увеличить значение счетчика, они могут переписывать результаты друг друга, что приведет к потере данных или неправильным результатам.
	- Вот пример на Go, демонстрирующий использование атомарных операций в асинхронных функциях:
		- Теперь давайте перепишем этот пример, используя атомарные операции:
		- ```go
		  package main
		  
		  import (
		  	"fmt"
		  	"sync"
		  	"sync/atomic"
		  )
		  
		  func worker(counter *uint64, wg *sync.WaitGroup) {
		  	// Инкрементируем счетчик атомарно
		  	atomic.AddUint64(counter, 1)
		  	wg.Done()
		  }
		  
		  func main() {
		  	var counter uint64 = 0
		  	var wg sync.WaitGroup
		  
		  	// Создаем 100 горутин
		  	for i := 0; i < 100; i++ {
		  		wg.Add(1)
		  		go worker(&counter, &wg)
		  	}
		  
		  	// Ожидаем завершения всех горутин
		  	wg.Wait()
		  
		  	// Выводим результат
		  	fmt.Println("Counter value:", counter)
		  }
		  ```
		- В этом примере мы используем мьютекс (mutex) для блокировки доступа к общему ресурсу (счетчику) во время его изменения. Это гарантирует, что только одна горутина может изменять значение счетчика в определенный момент времени, предотвращая гонку данных.
		- ```go
		  package main
		  
		  import (
		  	"fmt"
		  	"sync"
		  	"sync/atomic"
		  )
		  
		  var counter uint64
		  
		  func increment() {
		  	atomic.AddUint64(&counter, 1)
		  }
		  
		  func main() {
		  	var wg sync.WaitGroup
		  
		  	for i := 0; i < 100; i++ {
		  		wg.Add(1)
		  		go func() {
		  			defer wg.Done()
		  			increment()
		  		}()
		  	}
		  
		  	wg.Wait()
		  	fmt.Println("Counter value:", counter)
		  }
		  
		  ```
		- Здесь мы используем функцию `atomic.AddUint64` для безопасного инкремента значения счетчика. Это обеспечивает безопасность при изменении счетчика в многопоточной среде, не требуя явного использования мьютекса.
- ###  эвакуация карты (map evacuation)
  collapsed:: true
	- В контексте Go "эвакуация карты" (map evacuation) обычно связана с процессом, который происходит в сборщике мусора (garbage collector) Go.
	- В Go сборщик мусора отслеживает использование памяти и автоматически освобождает память, которая больше не используется. Одним из аспектов работы сборщика мусора является управление памятью, используемой для хранения карт (map) в Go.
	- Эвакуация карты происходит, когда карта нуждается в расширении своей внутренней структуры для поддержки дополнительных элементов. Поскольку карта может содержать переменное количество элементов и должна быть гибкой, чтобы поддерживать их, иногда требуется изменить размер внутренних структур данных карты.
	- Когда карта переполняется, ее внутренняя структура данных может быть перемещена в другое место в памяти, чтобы сделать ее больше. Этот процесс перемещения внутренней структуры называется эвакуацией карты.
	- Эвакуация карты обычно происходит незаметно для программы, и сборщик мусора Go заботится об этом автоматически. Однако это важно понимать, особенно при проектировании производительных приложений на Go, так как эвакуация карты может вызвать задержки в выполнении программы из-за переноса данных в другое место в памяти.
- ### workerpool
- ### семафор
- ### контракт
  collapsed:: true
	- интерфейс с методами
- ### DAO (document access object)
	-