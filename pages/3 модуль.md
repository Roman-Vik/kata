## 1 Применение хороших практик
	- [[Что такое принцип DRY (Don’t Repeat Yourself)]]
	- [[Что такое принцип YAGNI (You Ain’t Gonna Need It)]]
	- [[Что такое принцип KISS (Keep It Simple, Stupid]]
	- [[bshcxbdshbc]]
	-
- ## SOLID
  collapsed:: true
	- [[Что такое SOLID]]
	- [[Назови принципы SOLID]]
	- [[Что такое Single Responsibility Principle?]]
	- [[Что такое Open / Closed Principle]]
	- [[Что такое  Liskov Substitution Principle]]
	- [[Что такое Interface Segregation Principle]]
	- [[Что такое Dependency Inversion Principle]]
- ## Рефакторинг
	- [[Что такое рефакторинг]]
	- [[Что такое грязный код]]
- #### **2 Применение ООП**
  collapsed:: true
	- [[Является ли язык golang ООП языком?]]
	- [[Абстракция]]
	- [[Полиморфизм в go:]]
	- [[Отчилия Абстракции от Полиморфизма]]
	- [[Инкапсуляция]]
- [Введение в ООП. Наследование, абстракция, полиморфизм, инкапсуляция.](https://proglib.io/p/samouchitel-po-go-dlya-nachinayushchih-chast-10-vvedenie-v-oop-nasledovanie-abstrakciya-polimorfizm-inkapsulyaciya-2024-03-11)
- ####  2.3 создание конструктора объекта
  collapsed:: true
	- **Планирование**
	  collapsed:: true
		- — это процесс определения целей программы или кода, спецификаций, требований и архитектуры системы.
		- Это важный этап, позволяет определить цели проекта, спецификации, требования и архитектуру системы и включает в себя определение функциональности, создание диаграмм, определение интерфейсов и тестирование.
		-
	- #### Модель  «водопад»  (waterfall model)
	  collapsed:: true
		- классическая моделей жизненного цикла разработки программного обеспечения, кторая включает в себя этапа разработки:
		- определение требований;
		  logseq.order-list-type:: number
		- проектирование;
		  logseq.order-list-type:: number
		- разработку;
		  logseq.order-list-type:: number
		- тестирование;
		  logseq.order-list-type:: number
		- внедрение.
		  logseq.order-list-type:: number
		- Этапы предполагают последовательное выполнение, где каждый следующий этап начинается только после завершения предыдущего.
	- #### Зачем нужен мигратор?  Мигратор: Упрощенный пример
		- Мигратор нужен, чтобы автоматически создавать таблицы в базе данных на основе структур (моделей) в вашем коде. Это помогает автоматизировать и упростить процесс работы с базой данных, избегая ручного создания таблиц.
		- ### Входные данные для мигратора
		  
		  Мигратор должен получать:
		- **Подключение к базе данных** (`*sql.DB`): чтобы иметь возможность выполнять SQL-запросы.
		- **Генератор SQL-запросов** (`SQLGenerator`): который знает, как создать SQL-запрос для создания таблиц.
		- **Модели** (`Tabler`): структуры данных, которые описывают таблицы, которые нужно создать.
		- ### Основные задачи мигратора
		- **Инициализация**: создать мигратор с подключением к базе данных и генератором SQL-запросов.
		- **Создание таблиц**: пройтись по каждой модели, сгенерировать SQL-запрос для создания таблицы и выполнить его в базе данных.
		- **Обработка ошибок**: если не удалось создать таблицу, вернуть ошибку с информацией о модели и причине ошибки.
		- ###
		- Мигратор создаёт таблицы в базе данных на основе переданных ему моделей.
		- #### Шаг 1: Определение модели
		  
		  Определим простую модель, представляющую таблицу в базе данных. В данном примере это будет таблица для хранения информации о книгах.
		  
		  ```go
		  package main
		  
		  type Book struct {
		  ID     int
		  Title  string
		  Author string
		  }
		  
		  func (b *Book) TableName() string {
		  return "books"
		  }
		  ```
		- #### Шаг 2: Интерфейсы
		  
		  Создадим интерфейсы для таблицы и генератора SQL-запросов.
		  
		  ```go
		  type Tabler interface {
		  TableName() string
		  }
		  
		  type SQLGenerator interface {
		  CreateTableSQL(table Tabler) string
		  }
		  ```
		- #### Шаг 3: Реализация генератора SQL-запросов
		  
		  Генератор SQL-запросов создаёт SQL-команды для создания таблиц.
		  
		  ```go
		  type SimpleSQLGenerator struct{}
		  
		  func (g *SimpleSQLGenerator) CreateTableSQL(table Tabler) string {
		  switch table.(type) {
		  case *Book:
		  return fmt.Sprintf("CREATE TABLE %s (ID INTEGER PRIMARY KEY, Title TEXT, Author TEXT);", table.TableName())
		  default:
		  return ""
		  }
		  }
		  ```
		- #### Шаг 4: Реализация мигратора
		  
		  Мигратор использует генератор SQL-запросов для создания таблиц в базе данных.
		  
		  ```go
		  import (
		  "database/sql"
		  "fmt"
		  "log"
		  
		  _ "github.com/mattn/go-sqlite3"
		  )
		  
		  type Migrator struct {
		  db           *sql.DB
		  sqlGenerator SQLGenerator
		  }
		  
		  func NewMigrator(db *sql.DB, sqlGenerator SQLGenerator) *Migrator {
		  return &Migrator{
		  db:           db,
		  sqlGenerator: sqlGenerator,
		  }
		  }
		  
		  func (m *Migrator) Migrate(models ...Tabler) error {
		  for _, model := range models {
		  sql := m.sqlGenerator.CreateTableSQL(model)
		  _, err := m.db.Exec(sql)
		  if err != nil {
		  	return fmt.Errorf("failed to create table for model %s: %v", model.TableName(), err)
		  }
		  }
		  return nil
		  }
		  ```
		- #### Шаг 5: Основная функция
		  
		  Основная функция создаёт подключение к базе данных и выполняет миграцию.
		  
		  ```go
		  import (
		  "database/sql"
		  "log"
		  
		  _ "github.com/mattn/go-sqlite3"
		  )
		  
		  func main() {
		  db, err := sql.Open("sqlite3", "file:books.db?cache=shared&mode=rwc")
		  if err != nil {
		  log.Fatalf("failed to connect to the database: %v", err)
		  }
		  defer db.Close()
		  
		  sqlGenerator := &SimpleSQLGenerator{}
		  migrator := NewMigrator(db, sqlGenerator)
		  
		  if err := migrator.Migrate(&Book{}); err != nil {
		  log.Fatalf("failed to migrate: %v", err)
		  }
		  }
		  ```
		- ### Объяснение
		- **Модель данных (Book)**: Описывает структуру таблицы с полями ID, Title и Author.
		- **Интерфейсы (Tabler и SQLGenerator)**: Определяют необходимые методы для работы с таблицами и генерацией SQL-запросов.
		- **Генератор SQL-запросов (SimpleSQLGenerator)**: Создаёт SQL-команду для создания таблицы на основе переданной модели.
		- **Мигратор (Migrator)**: Использует генератор SQL-запросов для создания таблиц в базе данных.
		- **Основная функция (main)**: Создаёт подключение к базе данных, создаёт мигратор и выполняет миграцию таблицы.
		  
		  Этот упрощенный пример показывает основную идею работы мигратора без лишних сложностей и деталей.
	- #### Ассоциация (has-a) и Агрегация (has-a) в голанг
	  collapsed:: true
		- ### Ассоциация
		  
		  Ассоциация представляет собой общее отношение между двумя классами, где один класс использует функциональность другого класса. Это отношение не обязательно указывает на владение одним классом другим. Например, врач может быть ассоциирован с несколькими пациентами, но это не означает, что врач "владеет" пациентами в смысле управления их жизненным циклом.
		- В Go, как и в других языках программирования, концепции ассоциации (has-a) и агрегации (has-a) используются для описания отношений между объектами или структурами данных. Однако, важно понимать, что Go не поддерживает классическое наследование и полноценные объекты в том смысле, как это делают языки с поддержкой классов. Вместо этого, Go использует структуры и интерфейсы для достижения подобного поведения. Давайте рассмотрим эти концепции на примере.
		- ### Ассоциация
		  
		  Ассоциация означает, что одна структура содержит ссылку на другую структуру. Это может быть реализовано через поля структур. В контексте Go, это часто называют "владением" (`has-a`), но более точное название — это просто "ассоциация", поскольку владение подразумевает возможность управления жизненным циклом объекта, чего нет в Go из-за его систем управления памятью.
		  
		  Пример ассоциации:
		  
		  ```go
		  type Car struct {
		    brand string
		  }
		  
		  type Person struct {
		    name   string
		    car    *Car // Ассоциация: у человека есть машина
		  }
		  ```
		  
		  В этом примере, `Person` ассоциирован с `Car`, имея в себе указатель на `Car`. Это позволяет `Person` иметь доступ к свойствам и методам `Car`.
		- ### Агрегация
		  
		  Агрегация — это специальный случай ассоциации, где одна структура включает в себя другие структуры без явного представления отношения владения. В Go, агрегация обычно достигается путем включения структур напрямую в составной тип без использования указателей или интерфейсов.
		  
		  Пример агрегации:
		- ```go
		  type Engine struct {
		    power int
		  }
		  
		  type Car struct {
		    brand string
		    engine Engine // Агрегация: машина состоит из двигателя
		  }
		  ```
		  
		  Здесь `Car` агрегирует `Engine`, включая его непосредственно в свою структуру. Это позволяет `Car` использовать свойства и методы `Engine`, но без явного отражения отношения владения через указатели.
		- ### Отличие
		  
		  Основное отличие между ассоциацией и агрегацией заключается в способе связи между структурами:
		- **Ассоциация** обычно реализуется через указатели или интерфейсы, что позволяет одной структуре управлять другой или изменять связь во время выполнения программы.
		- **Агрегация** достигается за счет прямого включения одной структуры в составную структуру, что создает статическую связь между ними.
		  
		  В Go, выбор между ассоциацией и агрегацией зависит от конкретных требований к дизайну и взаимодействию между компонентами системы.
		-
		- ### Ассоциация
		  
		  Ассоциация представляет собой общее отношение между двумя классами, где один класс использует функциональность другого класса. Это отношение не обязательно указывает на владение одним классом другим. Например, врач может быть ассоциирован с несколькими пациентами, но это не означает, что врач "владеет" пациентами в смысле управления их жизненным циклом.
		- ### Агрегация
		  
		  Агрегация является специальным случаем ассоциации, который описывает отношение "целое-часть", где части могут существовать независимо от целого. Например, список номеров телефонов может быть агрегатом, состоящим из множества отдельных номеров телефонов. Каждый номер телефона может существовать независимо от списка.
		- ### Основные различия
		- **Отношение**: Ассоциация описывает общее использование функциональности одного класса другим, в то время как агрегация описывает отношение "целое-часть", где части могут существовать независимо.
		- **Владение**: В ассоциации нет явного указания на владение, тогда как в агрегации части могут существовать независимо от целого.
		- **Примеры**: Врач-пациент (ассоциация) против списка номеров телефонов (агрегация).
		- ### Примеры на Go
		  
		  Поскольку Go не имеет классического наследования и полноценных объектов, мы можем использовать структуры и интерфейсы для демонстрации этих концепций.
		- #### Ассоциация
		  
		  ```go
		  type Doctor struct{}
		  
		  type Patient struct{}
		  
		  func (d *Doctor) Treat(p *Patient) {}
		  ```
		  В этом примере, `Doctor` ассоциирован с `Patient`, но не "владеет" им в смысле управления жизненным циклом.
		- #### Агрегация
		- ```go
		  type PhoneNumber struct {
		    Number string
		  }
		  
		  type ContactList struct {
		    Phones []PhoneNumber
		  }
		  ```
		  
		  Здесь `ContactList` агрегирует `PhoneNumber`, но каждый номер телефона может существовать независимо от списка контактов.
		  
		  Эти примеры иллюстрируют основные различия между ассоциацией и агрегацией, подчеркивая, что в Go эти концепции реализуются через структуры и интерфейсы, а не через механизмы наследования и полноценных объектов, как в некоторых других языках программирования.
- 2.5 Мок тестирование с помощью mockery/mockgen
- #### **3 Паттерны**
- #### **4 Структуры данных и алгоритмы**
	- **Сложность алгоритма **— это мера количества ресурсов (времени и памяти), необходимых для выполнения алгоритма в зависимости от размера входных данных.
	- **Big O нотация** — это способ описать, как быстро увеличивается время выполнения алгоритма или его потребление памяти по мере увеличения размера входных данных. Она помогает понять, насколько эффективен алгоритм и как он будет вести себя при обработке больших объемов данных
	- ### Зачем это нужно?
	  
	  **Big O нотация** помогает выбрать наиболее эффективный алгоритм для решения задачи, особенно когда работаешь с большими данными. Понимая, как алгоритм масштабируется, можно прогнозировать его производительность и избегать ситуаций, когда программа становится слишком медленной или использует слишком много памяти.
	- ## Временная сложность (Time Complexity)
	  collapsed:: true
		- ### Что такое временная сложность?
		  
		  Временная сложность — это способ измерить, сколько времени (в количестве операций) потребуется алгоритму для завершения работы в зависимости от количества входных данных.
		- ### Пример из повседневной жизни
		  
		  Представь, что ты хочешь найти определенную книгу на полке:
		- Если на полке одна книга, ты найдешь её моментально.
		- Если на полке 10 книг, тебе потребуется немного больше времени, чтобы перебрать их все.
		- Если на полке 100 книг, времени потребуется еще больше.
		  
		  Временная сложность показывает, как увеличивается время поиска книги, если на полке становится больше книг.
	- ## Пространственная сложность (Space Complexity)
	  collapsed:: true
		- Пространственная сложность — это мера того, сколько памяти потребуется алгоритму для выполнения своей работы, в зависимости от размера входных данных. Точно так же, как временная сложность показывает, сколько времени нужно алгоритму, пространственная сложность показывает, сколько памяти нужно.
		- ### Что такое пространственная сложность?
		  
		  Пространственная сложность — это мера того, сколько памяти потребуется алгоритму для выполнения своей работы, в зависимости от размера входных данных. Точно так же, как временная сложность показывает, сколько времени нужно алгоритму, пространственная сложность показывает, сколько памяти нужно.
		- ### Простое сравнение с реальной жизнью
		  
		  Представь, что ты пакуешь вещи в коробки:
		- Если у тебя есть 1 вещь, тебе нужна всего одна маленькая коробка.
		- Если у тебя 10 вещей, тебе потребуется больше коробок или одна большая коробка.
		- Если у тебя 100 вещей, потребуется еще больше коробок или несколько больших коробок.
		  
		  Пространственная сложность показывает, как будет увеличиваться количество необходимой памяти (или коробок), когда количество вещей (данных) увеличивается.
	- [[Основные категории Big O]]
	- [[Существует ещё несколько важных аспектов, которые могут быть использованы для оценки и сравнения алгоритмов]]
	- ### [[Алгоритмы]]
	-
- #### ** Оптимизация**
- ### Понятия
	- [[Что такое контракт?]]
	- [[Типы, подтипы что это такое]]
	- [[Основные моменты Принципа Подстановки Лисков]]
	- [[Принцип подстановки Лисков vs Утиная типизация]]
	- [[Отличия Принципа ]]
-