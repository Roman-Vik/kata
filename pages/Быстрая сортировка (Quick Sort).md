- Тут смысл в чем `func partition` отвечает за разделение от числа на правую и лефую строну
- `func quicSort` проверяет  рекурсивно делит эти половники  пока они не закончатся
- ### Алгоритм быстрой сортировки (QuickSort)
  
  QuickSort — это эффективный алгоритм сортировки, использующий метод "разделяй и властвуй". Алгоритм работает следующим образом:
- **Выбор опорного элемента (pivot)**.
- **Разделение массива**: все элементы, меньшие опорного элемента, перемещаются влево от него, а все элементы, большие или равные опорному элементу, перемещаются вправо.
- **Рекурсивное применение** к подмассивам слева и справа от опорного элемента.
- ### Полный код с подробными комментариями
  
  ```go
  package main
  
  import "fmt"
  
  // Функция быстрой сортировки
  func quickSort(arr []int, low, high int) {
    // Если в подмассиве больше одного элемента
    if low < high {
        // Получаем индекс опорного элемента после разделения массива
        pi := partition(arr, low, high)
        
        // Рекурсивно сортируем подмассивы до и после опорного элемента
        quickSort(arr, low, pi-1)
        quickSort(arr, pi+1, high)
    }
  }
  
  // Функция для разделения массива на две части
  func partition(arr []int, low, high int) int {
    pivot := arr[high]  // Опорный элемент (pivot), выбираем последний элемент массива
    i := low - 1        // Индекс для элементов, которые меньше pivot
  
    // Проходим по массиву от low до high-1
    for j := low; j < high; j++ {
        // Если текущий элемент меньше опорного
        if arr[j] < pivot {
            i++  // Увеличиваем индекс меньшего элемента
            arr[i], arr[j] = arr[j], arr[i]  // Меняем местами элементы
        }
    }
    
    // Меняем местами опорный элемент и элемент, следующий за последним меньшим элементом
    arr[i+1], arr[high] = arr[high], arr[i+1]
    
    return i + 1  // Возвращаем индекс опорного элемента
  }
  
  // Главная функция
  func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90} // Исходный массив
    n := len(arr)                           // Получаем длину массива
    quickSort(arr, 0, n-1)                  // Вызываем быструю сортировку
    fmt.Println("Sorted array:", arr)       // Печатаем отсортированный массив
  }
  ```
- ### Пошаговое объяснение
- #### Исходный массив
  
  ```go
  arr := []int{64, 34, 25, 12, 22, 11, 90}
  ```
- #### Первый вызов  `quickSort`
  
  ```go
  quickSort(arr, 0, len(arr)-1)
  ```
- `low = 0`
- `high = 6` (индекс последнего элемента массива)
- #### Первый вызов  `partition`
  
  ```go
  partition(arr, 0, 6)
  ```
- **Опорный элемент (pivot)**: последний элемент массива `pivot = arr[6] = 90`.
- **Инициализация индекса `i`**: `i = low - 1 = -1`.
- **Проход по массиву от `low` до `high-1` (от 0 до 5)**:
	- Если элемент меньше pivot, увеличиваем `i` и меняем местами `arr[i]` и `arr[j]`.
	  
	  **Шаги прохода**:
	- `j = 0`: `arr[0] = 64` (меньше 90), `i = 0`, меняем `arr[0]` и `arr[0]` (не меняется).
	- `j = 1`: `arr[1] = 34` (меньше 90), `i = 1`, меняем `arr[1]` и `arr[1]` (не меняется).
	- `j = 2`: `arr[2] = 25` (меньше 90), `i = 2`, меняем `arr[2]` и `arr[2]` (не меняется).
	- `j = 3`: `arr[3] = 12` (меньше 90), `i = 3`, меняем `arr[3]` и `arr[3]` (не меняется).
	- `j = 4`: `arr[4] = 22` (меньше 90), `i = 4`, меняем `arr[4]` и `arr[4]` (не меняется).
	- `j = 5`: `arr[5] = 11` (меньше 90), `i = 5`, меняем `arr[5]` и `arr[5]` (не меняется).
- **Перемещаем pivot на его окончательное место**:
	- `arr[i+1], arr[high] = arr[high], arr[i+1]`
	- `i + 1 = 6`, меняем `arr[6]` и `arr[6]` (не меняется).
- **Возвращаем индекс pivot**: `6`.
  
  Массив после первого вызова `partition`: `[64, 34, 25, 12, 22, 11, 90]`
- #### Рекурсивные вызовы для подмассивов
  
  ```go
  quickSort(arr, 0, 5)
  quickSort(arr, 7, 6)
  ```
- **Левый подмассив**: `[64, 34, 25, 12, 22, 11]`
- **Правый подмассив**: пуст (все элементы уже меньше pivot).
- #### Продолжение процесса
  
  Этот процесс продолжается рекурсивно, разбивая каждый подмассив на все меньшие части и сортируя их, пока подмассивы не станут пустыми или содержат один элемент. В итоге массив будет отсортирован.
- ### Итоговый отсортированный массив
  
  После завершения всех рекурсивных вызовов, массив станет отсортированным:
  
  ```go
  [11, 12, 22, 25, 34, 64, 90]
  ```