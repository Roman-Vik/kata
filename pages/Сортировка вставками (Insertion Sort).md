- Внутренний цикл сортировки вставками действительно работает справа налево, то есть от текущего элемента к началу массива. Он сравнивает текущий элемент (который нужно вставить в отсортированную часть массива) с элементами, которые уже отсортированы, и перемещает их вправо, если они больше текущего элемента. Это продолжается до тех пор, пока не найдется правильное место для текущего элемента.
  
  Давайте еще раз посмотрим на упрощенный код с комментариями:
  
  ```go
  package main
  
  import "fmt"
  
  // Функция сортировки вставками
  func insertionSort(arr []int) {
      n := len(arr)
      // Внешний цикл проходит по всем элементам массива начиная со второго
      for i := 1; i < n; i++ {
          key := arr[i] // Сохраняем текущий элемент, который нужно вставить в отсортированную часть
          j := i - 1 // Инициализируем индекс для прохода по отсортированной части массива
          
          // Внутренний цикл перемещает элементы, которые больше текущего элемента key, вправо
          for j >= 0 && arr[j] > key {
              arr[j+1] = arr[j] // Сдвигаем элемент arr[j] вправо
              j-- // Переходим к следующему элементу слева
          }
          
          // Вставляем текущий элемент key на правильное место
          arr[j+1] = key
      }
  }
  
  func main() {
      arr := []int{64, 34, 25, 12, 22, 11, 90} // Инициализируем массив для сортировки
      fmt.Println("Original array:", arr) // Печатаем исходный массив
      insertionSort(arr) // Вызываем функцию сортировки вставками
      fmt.Println("Sorted array:", arr) // Печатаем отсортированный массив
  }
  ```
- ### Пошаговое объяснение:
- **Инициализация**:
	- `key = arr[i]` сохраняет текущий элемент, который нужно вставить в отсортированную часть массива.
	- `j = i - 1` устанавливает `j` на индекс элемента слева от текущего.
- **Внутренний цикл**:
	- `for j >= 0 && arr[j] > key` проверяет, не вышли ли мы за пределы массива (j >= 0) и больше ли текущий элемент `arr[j]`, чем `key`.
	- `arr[j+1] = arr[j]` сдвигает элемент `arr[j]` на одну позицию вправо, чтобы освободить место для `key`.
	- `j--` уменьшает `j`, двигаясь влево.
- **Вставка `key`**:
	- `arr[j+1] = key` вставляет текущий элемент `key` в правильное место в отсортированной части массива.